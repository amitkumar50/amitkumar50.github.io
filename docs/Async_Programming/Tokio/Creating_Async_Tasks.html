<!DOCTYPE html>
<html>
<head>
    <title>Creating Async Tasks</title>
    <!--<link rel="stylesheet" href="/css/styles.css"/>-->
    <link rel="stylesheet" href="/css/prism.css"/>
</head>

<body>
    <h2>Creating Async Tasks(Rust)</h2>
    <div class="tab">
          <button class="tablinks" onclick="opencode(event, 'rust-toks')">(tokio::spawn)</button>
          <button class="tablinks" onclick="opencode(event, 'rust-toksb')">(tokio::task::spawn_blocking)</button>
          <button class="tablinks" onclick="opencode(event, 'rust-blockon')">(block_on)</button>
    </div>

      <div id="rust-toks" class="tabcontent">
        <h3>tokio::spawn(Green Threads)</h3>
            <li>spawn Non-blocking tasks within tokio runtime</li>
            <li>Main thread will wait on JoinHandle(same as pthread_join)</li>
        <pre><code class="language-css">
            $ cat Cargo.toml
            [package]
            name = "tokio_spawn"
            version = "0.1.0"
            authors = ["amitk"]
            edition = "2018"

            [dependencies]
            futures = { version = "0.3.*" }
            tokio = {version = "0.2.*", features = ["full"] }

            ///////////////////////////////////////////////
            $ cat main.rs
            use tokio::task;
            async fn fun1() {
                println!("thread-1");
                tokio::time::delay_for(std::time::Duration::from_milli(5).await;
                println!("Back in thread-1");
                tokio::time::delay_for(std::time::Duration::from_milli(5000).await;
            }
            async fn fun2() {
                println!("thread-2");
            }
            #[tokio::main]
            async fn main() {

                let mut vec_join_handles:Vec<tokio::task::JoinHandle()>> = vec![];
                // spawn() returns `struct JoinHandle`
                //    This is similar to joining a thread in other programming languages.
                //    It allows you to wait for the task to complete and 
                //    obtain the result or handle any potential errors.
                let handle1 = task::spawn(async{ fun1().await });
                vec_join_handles.push(handle1);
                    
                let handle2 = task::spawn(async{ fun2().await });
                vec_join_handles.push(handle2);

                for i in vec_join_handles {
                    match i {
                        Ok(_) => {  // Task completed successfully
                            println!("Task completed successfully");
                        }
                        Err(e) => {    // Task encountered an error
                            println!("Task encountered an error: {:?}", e);
                        }
                    }
                }
            }
            $ cargo build
            $ cargo run
            thread-1
            thread-2
            Back to thread-1
        </code></pre>
    </div>

    <div id="rust-toksb" class="tabcontent">
        <h3>(tokio::task::spawn_blocking)</h3>
            <li>This spawn a blocking task into a separate thread from the Tokio runtime's thread pool</li>
            <li>while there can be other non-blocking tasks on tokio runtime</li>
        <pre><code class="language-css">
            $ Cargo.toml
            [dependencies]
            futures = { version = "0.3.*" }
            tokio = {version = "0.2.*", features = ["full"] }
            
            $ main.rs
            use tokio::task;
            
            fn fun() {
              println!("fun");
            }
            
            async fn fun(arg) {
                let threadpool_future = task::spawn_blocking(||fun());    //3. Call blocking or CPU-intensive function in seperate thread
                todo!()
            }
            
            fn main() {
                let mut rt:Runtime = tokio::runtime::Runtime::new().unwrap();     //1. Start tokio runtime
                let local:LocalSet = tokio::task::LocalSet::new();
                local.block_on (&mut rt, async move {
                  fun(arg).await
                });            //2. Spawn a future
            }
        </code></pre>
    </div>

    <div id="rust-blockon" class="tabcontent">
        <h3>Rust(futures::executor::block_on())</h3>
            <li>Run 1 future to completion and there is only thread within tokio</li>
            <li>There are no other tasks on tokio</li>
        <pre><code class="language-css">
             $ cat Cargo.toml
            [dependencies]
            futures = "0.3"
            
            $ cat main.rs
            use futures::executor::block_on;
            async fn fun1() { print!("fun1"); }
            async fn fun2() { print!("fun2"); }
            fn main() {
                block_on(fun1());                       //main() blocks until fun1(),fun2() does not compelte
                block_on(fun2());
            }
            $ main.exe
            fun1 fun2
        </code></pre>
    </div>
    
      <script>
        function opencode(evt, cityName) {
          var i, tabcontent, tablinks;
          tabcontent = document.getElementsByClassName("tabcontent");
          for (i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
          }
          tablinks = document.getElementsByClassName("tablinks");
          for (i = 0; i < tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
          }
          document.getElementById(cityName).style.display = "block";
          evt.currentTarget.className += " active";
        }
    </script>

    <script src="/scripts/prism.js"></script>
</body>

</html>
