<!DOCTYPE html>
<html>
<head>
    <title>Creating Async Tasks</title>
    <link rel="stylesheet" href="/css/styles.css"/>
</head>

<body>
    <div class="tab">
      <button class="tablinks" onclick="opencode(event, 'rust-toks')">Rust(tokio::spawn)</button>
      <button class="tablinks" onclick="opencode(event, 'rust-toksb')">Rust(tokio::task::spawn_blocking)</button>
    </div>

      <div id="rust-toks" class="tabcontent">
        <h3>Rust tokio::spawn(Green Threads)</h3>
        <pre>
            $ cat Cargo.toml
            [package]
            name = "tokio_spawn"
            version = "0.1.0"
            authors = ["amitk"]
            edition = "2018"

            [dependencies]
            futures = { version = "0.3.*" }
            tokio = {version = "0.2.*", features = ["full"] }

            $ cat main.rs
            use tokio::task;
            fn fun_thread() {
                println!("thread-1");
            }
            #[tokio::main]
            async fn main() {
                let join:JoinHandle<()> = task::spawn(async {		//spawn() returns `struct JoinHandle`
                    fun_thread()
                });
                assert!(join.await.is_err());
            }
            $ cargo build
            $ cargo run
            thread-1
        </pre>
    </div>

    <div id="rust-toksb" class="tabcontent">
        <h3>Rust(tokio::task::spawn_blocking)</h3>
        <pre>
            $ Cargo.toml
            [dependencies]
            futures = { version = "0.3.*" }
            tokio = {version = "0.2.*", features = ["full"] }
            
            $ main.rs
            use tokio::task;
            
            fn fun() {
              println!("fun");
            }
            
            async fn fun(arg) {
                let threadpool_future = task::spawn_blocking(||fun());    //3. Call blocking or CPU-intensive function in seperate thread
                todo!()
            }
            
            fn main() {
                let mut rt:Runtime = tokio::runtime::Runtime::new().unwrap();     //1. Start tokio runtime
                let local:LocalSet = tokio::task::LocalSet::new();
                local.block_on (&mut rt, async move {
                  fun(arg).await
                });            //2. Spawn a future
            }
        </pre>
    </div>

      <script>
        function opencode(evt, cityName) {
          var i, tabcontent, tablinks;
          tabcontent = document.getElementsByClassName("tabcontent");
          for (i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
          }
          tablinks = document.getElementsByClassName("tablinks");
          for (i = 0; i < tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
          }
          document.getElementById(cityName).style.display = "block";
          evt.currentTarget.className += " active";
        }
    </script>
  
</body>

</html>
