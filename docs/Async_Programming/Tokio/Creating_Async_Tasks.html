<!DOCTYPE html>
<html>
<head>
    <title>Creating Async Tasks</title>
    <link rel="stylesheet" href="/css/styles.css"/>
</head>

<body>
    <nav class="navbar">    <!--See .navbar in styles.css-->
        <ul>
          <li><a href="/">Home</a></li>
          <li><a href="#">Our team</a></li>
          <li><a href="#">Projects</a></li>
          <li><a href="/contact.html">Contact</a></li>
          <li>
            <form id="searchForm">
                <input type="search" id="searchInput" name="q" placeholder="Search site" />
                <input type="submit" value="Go!" />
            </form>
           </li>
        </ul>
    </nav>

    <aside class="sidebar">
        <a href="#cret">Creating Async Tasks(Rust)</a>
    </aside>

    <article style="margin-left:200px;">
        <h3 id="creat">Ways to create Async Tasks(Rust)</h3>
        <table>
            <tr>
                <th></th>
                <th>tokio::spawn(Green Threads)</th>
                <th>tokio::task::spawn_blocking</th>
                <th>block_on</th>
            </tr>
            <tr>
                <td>What</td>
                <td>
    - spawn Non-blocking tasks within tokio runtime<br>
    - Main thread will wait on JoinHandle(same as pthread_join)
                </td>
                <td>
    - This spawn a blocking task into a separate thread from the Tokio runtime's thread pool<br>
    - while there can be other non-blocking tasks on tokio runtime
                </td>
                <td>
    - Run 1 future to completion and there is only thread within tokio<br>
    - There are no other tasks on tokio
                </td>
            </tr>

            <tr>
                <td>Code</td>
                <td><pre>
    $ cat Cargo.toml
    [package]
    name = "tokio_spawn"
    version = "0.1.0"
    authors = ["amitk"]
    edition = "2018"
    
    [dependencies]
    futures = { version = "0.3.*" }
    tokio = {version = "0.2.*", features = ["full"] }
    
    ///////////////////////////////////////////////
    $ cat main.rs
    use tokio::task;
    async fn fun1() {
        println!("thread-1");
        tokio::time::delay_for(std::time::Duration::from_milli(5).await;
        println!("Back in thread-1");
        tokio::time::delay_for(std::time::Duration::from_milli(5000).await;
    }
    async fn fun2() {
        println!("thread-2");
    }
    #[tokio::main]
    async fn main() {
    
        let mut vec_join_handles:Vec<tokio::task::JoinHandle()>> = vec![];
        // spawn() returns `struct JoinHandle`
        //    This is similar to joining a thread in other programming languages.
        //    It allows you to wait for the task to complete and 
        //    obtain the result or handle any potential errors.
        let handle1 = task::spawn(async{ fun1().await });
        vec_join_handles.push(handle1);
            
        let handle2 = task::spawn(async{ fun2().await });
        vec_join_handles.push(handle2);
    
        for i in vec_join_handles {
            match i {
                Ok(_) => {  // Task completed successfully
                    println!("Task completed successfully");
                }
                Err(e) => {    // Task encountered an error
                    println!("Task encountered an error: {:?}", e);
                }
            }
        }
    }
    $ cargo build
    $ cargo run
    thread-1
    thread-2
    Back to thread-1
                </pre></td>
    
                <td><pre>
    $ Cargo.toml
    [dependencies]
    futures = { version = "0.3.*" }
    tokio = {version = "0.2.*", features = ["full"] }
    
    $ main.rs
    use tokio::task;
    
    fn fun() {
        println!("fun");
    }
    
    async fn fun(arg) {
        let threadpool_future = task::spawn_blocking(||fun());    //3. Call blocking or CPU-intensive function in seperate thread
        todo!()
    }
    
    fn main() {
        let mut rt:Runtime = tokio::runtime::Runtime::new().unwrap();     //1. Start tokio runtime
        let local:LocalSet = tokio::task::LocalSet::new();
        local.block_on (&mut rt, async move {
            fun(arg).await
        });            //2. Spawn a future
    }
                </pre></td>
    
                <td><pre>
    $ cat Cargo.toml
    [dependencies]
    futures = "0.3"
    
    $ cat main.rs
    use futures::executor::block_on;
    async fn fun1() { print!("fun1"); }
    async fn fun2() { print!("fun2"); }
    fn main() {
        block_on(fun1());                       //main() blocks until fun1(),fun2() does not compelte
        block_on(fun2());
    }
    $ main.exe
    fun1 fun2
                </pre></td>
            </tr>            
        </table>

    </article>

    

</body>
</html>
