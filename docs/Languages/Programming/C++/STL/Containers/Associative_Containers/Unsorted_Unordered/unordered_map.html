<!DOCTYPE html>
<html>
<head>
    <title>C++(unordered_map), Rust(HashMap), Python(Dictionary {}), Go </title>
    <link rel="stylesheet" href="/css/styles.css"/>
    <link rel="stylesheet" href="/css/prism.css"/>
</head>

<body>
    <h1>unordered_map</h1>
    <ul>
      <li>
          <h3><a href="#comp">C++, Rust, Python, Go</a></h3>
      </li>
    </ul>

    <h3 id="comp">C++ vs Rust vs Python</h3>
    <table>
        <tr>
            <th></th>
            <th>C++</th>
            <th>Rust (use std::collections::HashMap)</th>
            <th>Python ({} Dictionary)</th>
            <th>Go</th>
        </tr>
        <tr>
            <td>Create</td>
            <td><pre><code class="language-css">
unordered_map<string, int> um;
            </code></pre></td>

            <td><ul>    <!--Rust-->
                <li><b>Empty:</b> let hm:HashMap = HashMap::new()</li>
                <li><b>init</b> 
                    <ul>
                        <li><b>iter():</b> is called on the array to create an iterator over its elements</li>
                        <li><b>cloned():</b> method is used to clone each tuple's elements.<br>
                            This is necessary because &str is a reference type, <br>
                            and we need to create owned values to store in the HashMap.</li>
                        <li><b>collect()</b> method consumes the iterator and collects <br>
                            the cloned tuples into a HashMap<char, &str>.</li>
                    </ul>
                    <pre><code class="language-css">
let hm: HashMap<i32, &str> = [
    (2, "abc"),
    (3, "def"),
    (4, "ghi"),
    (5, "jkl"),
    (6, "mno"),
    (7, "pqrs"),
    (8, "tuv"),
    (9, "wxyz"),
]
.iter()
.cloned()
.collect();
            </code></pre>
                </li>
            </ul></td>

            <td><pre><code class="language-css">        <!--Python-->
self.hm = {}    #Empty
self.hm={1:1, 2:2}  #key,val
                </code></pre>
            </td>

            <td><pre><code class="=language-css">       <!--Go-->
var hm map[string[int]]  //key=string, value=int

// Using make function (key=pointer, val="pointer")
var hm = make(map[*Node]*Node)
            </code></pre></td>
        </tr>

        <tr>
            <td>Delete/Erase</td>
            <td><ul>    <!--c++-->
                <li>um.erase(key)</li>
                <li><b>Range:</b> um.erase(start,end)</li>
            </ul></td>
            <td></td>   <!--Rust-->
            <td></td>   <!--Python-->
            <td>        <!--Go-->
            </td>
        </tr>

        <tr>
            <td>Find</td>
            <td><pre><code class="language-css">    <!--C++-->
// Method1
if (um.find("key") != um.end())
   //Do
// Method2
  value=count(key)
// Smallest Key
  min_element(um.begin(), um.end())
            </code></pre></td>
            <td><pre><code class="language-css">    <!--Rust-->
if let Some(value) = hm.get(&key) {
    //value returned
} else {
    // Not found
}
            </code></pre></td>
            <td>                                   <!--Python-->
                value = um[key]
            </td>
            <td><pre><code class="language-css">        <!--Go-->
value = hm[key]
if value != nil {
    //Found
}
            </code></pre></td>
        </tr>

        <tr>
            <td>Insert</td>
            <td>vec.insert(v.begin() + 2, 7)</td>   <!--c++-->
            <td></td>
            <td></td>
            <td>                                    <!--Go-->
                <pre><code class="language-css">
hm["test"] = 1
                </code></pre>
            </td>

        </tr>
    </table>

    <script src="/scripts/prism.js"></script>
</body>

</html>
