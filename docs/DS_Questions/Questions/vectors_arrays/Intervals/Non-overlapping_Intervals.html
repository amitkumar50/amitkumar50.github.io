<!DOCTYPE html>
<html>
<head>
    <title>Non overlapping Intervals</title>
    <!--<link rel="stylesheet" href="/css/styles.css"/>-->
    <link rel="stylesheet" href="/css/prism.css"/>
</head>
    
<body>

    <h1><a href="https://leetcode.com/problems/non-overlapping-intervals/description/">435. Non-overlapping Intervals</a></h1>
    <p>Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</p>
    <pre><code>
      Example 1:
      Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
      Output: 1
      Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
      
      Example 2:
      Input: intervals = [[1,2],[1,2],[1,2]]
      Output: 2
      Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
      
      Example 3:
      Input: intervals = [[1,2],[2,3]]
      Output: 0
      Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
    </code></pre>

    <ul>
        <li><h2><a href="#a1">Approach-1. Interval Scheduling algorithm</a></h2></li>
    </ul>

    <h2 id="a1">Approach-1. Double Linked List+Hashtable. Time: O(1), Space: O(n)</h2>
    <h3><a href="https://amitkumar50.github.io/DS_Questions/Algorithms/IntervalScheduling_or_IntervalGreedy/IntervalScheduling_or_IntervalGreedy.html"/>Logic</a>/h3>
  
    <h3>Code</h3>
    <div class="tab">
        <button class="tablinks" onclick="opencode(event, 'cpp98')">CPP98</button>
        <button class="tablinks" onclick="opencode(event, 'cpp11')">CPP11</button>
        <button class="tablinks" onclick="opencode(event, 'python')">Python</button>
    </div>

        <!-- Tab content -->
    <div id="cpp98" class="tabcontent">
        <h3>CPP98</h3>
        <pre><code class="language-css">
          bool comp(vector<int> &a,vector<int> &b) {
          	return a[1]<b[1];
          }
          class Solution {
          public:
          	int eraseOverlapIntervals(vector<vector<int>>& intervals) {
          		int out = 0;
          
          		if (!intervals.size()) 
                      		return 0;
          
          		/*	Sort on endi
          			[[1,2],[2,3],[3,4],[1,3]]
          			becomes
          			[[1,2],[1,3],[2,3],[3,4]]
          		*/
          		sort(intervals.begin(),intervals.end(),comp);
          
          		// Take endi of 1st interval
          		int b1 = intervals[0][1];
          
          		/*	if (present_endi > next_starti)
          				- out++. This is overlapping interval
          			else
          				- point a to next element, because we need to reach element 
          				- where present_endi > next_starti
          		*/
          		for(int i=1;i<intervals.size();++i) {
                			int a2 = intervals[i][0], b2 = intervals[i][1];
          			if(b1 > a2)
          				out++;
                			else
                  			b1 = b2;
          		}
          		return out;
          	}
          };
        </code></pre>
    </div>

    <div id="cpp11" class="tabcontent">
        <h3>CPP11</h3>
        <pre><code class="language-css">
          class Solution {
          public:
          	int eraseOverlapIntervals(vector<vector<int>>& intervals) {
                 		int out = 0;
          
                  	if (!intervals.size())
          			return 0;
          
              		/*	Sort on endi
              			[[1,2],[2,3],[3,4],[1,3]]
              			becomes
              			[[1,2],[1,3],[2,3],[3,4]]
              		*/                                            //[] lambda not taking any outside param
          		std::sort(intervals.begin(), intervals.end(), [](const std::vector<int>& a, const std::vector<int>& b) {
                      		return a[1] < b[1];
                  	});
          
                  	int b1 = intervals[0][1];
              		/*	if (present_endi > next_starti)
              				- out++. This is overlapping interval
              			else
              				- point a to next element, because we need to reach element 
              				- where present_endi > next_starti
              		*/                                                  //& = lambda taking all outside param
          		std::for_each(intervals.begin()+1, intervals.end(), [&](const vector<int>& v) {
          			int a2 = v[0], b2 = v[1];
          			if (b1>a2)
          				out++;
          			else
          				b1 = b2;
          		});
                  return out;
              }
          };
        </code></pre>
    </div>

    <div id="python" class="tabcontent">
        <h3>Python</h3>
        <pre><code class="language-css">
          class Solution:
              def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
                  out = 0
                  """
                      Sort on endi
          			[[1,2],[2,3],[3,4],[1,3]]
          			becomes
          			[[1,2],[1,3],[2,3],[3,4]]
          		""" 
                  def custom_comparator(s):
                      return s[1]
                  intervals = sorted(intervals, key=custom_comparator)
          
                  b1 = intervals[0][1]
          
                  for (a2,b2) in intervals:
                      if b1 > a2:
                          out += 1
                      else:
                          b1 = b2
                  
                  return out-1
        </code></pre>
    </div>

      <script src="/scripts/prism.js"></script>
      <script src="/scripts/common.js"></script>
</body>
</html>
